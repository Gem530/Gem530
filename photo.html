<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>摄像头</title>
  <link rel="icon" href="./img/favicon.ico">
  <style>
    .photo-overflow {
      border: 1px solid gray;
    }
    
    .video-contain {
      border: 1px solid #f00;
      object-fit: cover;
      object-position: 0 0;
      left: 0;
    }
  </style>
  <script src="./vue.js"></script>
</head>
<body>
  <div id="app">
    <div>err:{{error}}</div>
    <div class="photo-overflow" :style="`width: ${widthD}px;height: ${heightD}px;`">
      <video
        class="video-contain"
        ref="video"
        id="video"
        :width="widthD"
        :height="heightD"
        autoplay
      ></video>
      <!-- <img
        class="video-contain"
        ref="video"
        id="video"
        src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fbpic.588ku.com%2Felement_origin_min_pic%2F16%2F10%2F29%2F2ac8e99273bc079e40a8dc079ca11b1f.jpg&refer=http%3A%2F%2Fbpic.588ku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637389812&t=02c65a6ed86d4cacf7b8335c66778970"
        :width="clientWidthD"
        :height="clientHeightD"
      /> -->
    </div>
    <canvas ref="canvas" :width="widthD" :height="heightD" style="display: none;"></canvas>
    <button @click="getPhoto">拍照</button>

    <img :src="imgURL" alt="">
  </div>

  <script>
    new Vue({
      el: '#app',
      data: {
        imgURL: '',
        widthD: 300,
        heightD: 200,
        clientWidthD: 0,
        clientHeightD: 0,
        error: '1'
      },
      created() {
        this.initPhoto()
      },
      mounted () {
      },
      methods: {
        // 初始化 摄像头
        initPhoto () {
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          const that = this
          this.$nextTick(() => {
            that.clientWidthD = document.body.clientWidth
            that.clientHeightD = document.body.clientHeight
            const navigators = navigator
            // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象
            if (navigators.mediaDevices === undefined) {
              navigators.mediaDevices = {}
            }
            // 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia
            // 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。
            if (navigators.mediaDevices.getUserMedia === undefined) {
              navigators.mediaDevices.getUserMedia = function (constraints) {
                // 首先，如果有getUserMedia的话，就获得它
                const getUserMedia = navigators.webkitGetUserMedia || navigators.mozGetUserMedia
                // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口
                if (!getUserMedia) {
                  return Promise.reject(new Error('getUserMedia is not implemented in this browser'))
                }
                // 否则，为老的navigator.getUserMedia方法包裹一个Promise
                return new Promise(function (resolve, reject) {
                  getUserMedia.call(navigators, constraints, resolve, reject)
                })
              }
            }
            navigators.mediaDevices.getUserMedia({
              audio: false,
              video: {
                facingMode: 'environment'
                // 放在app里面需要下面配置一下
                // 'permissions': {
                //   'audio-capture': {
                //     'description': 'Required to capture audio using getUserMedia()'
                //   },
                //   'video-capture': {
                //     'description': 'Required to capture video using getUserMedia()'
                //   }
                // }
              }
              // width: this.widthD,
              // height: this.heightD,
            })
              .then(function (stream) {
                console.log(stream, 'stream', that.widthD, that.heightD, that.clientWidthD, that.clientHeightD)
                const video = that.$refs.video
                // 旧的浏览器可能没有srcObject
                if ('srcObject' in video) {
                  video.srcObject = stream
                } else {
                  // 防止在新的浏览器里使用它，应为它已经不再支持了
                  video.src = window.URL.createObjectURL(stream)
                }
                // video.onloadedmetadata = function () {
                //   video.play()
                // }
              })
              .catch(function (err) {
                console.log(err.name + ': ' + err.message)
                that.error = err.name +': ' + err.message
              })
          })
        },
        // 拍照
        getPhoto () {
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          const that = this
          const video = that.$refs.video
          const canvas = that.$refs.canvas
          const ctx = canvas.getContext('2d')
          canvas.width = this.widthD
          canvas.height = this.heightD
          video.crossOrigin = 'anonymous'
          ctx.drawImage(video, 0, 0, this.widthD, this.heightD, 0, 0, this.widthD, this.heightD)
          // ctx.drawImage(video, 0, 0, this.widthD, this.heightD, 0, 0, this.widthD, this.heightD)
          // drawImage(img,sx,sy,swidth,sheight,x,y,width,height) : 剪切图像，并在画布上
          // sx 开始剪切的图片上的x位置
          // sy 开始剪切的图片上的y位置
          // swidth 被剪切的宽度
          // sheight 被剪切的高度
          // x 在画布上放置图像的x位置
          // y 在画布上放置图像的y位置
          // width 要使用的图像宽度
          // height 要使用的图像高度
          const dataURL = canvas.toDataURL('image/jpeg')
          that.imgURL = dataURL
          console.log(11)
          // const img = new Image()
          // img.src = 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fbpic.588ku.com%2Felement_origin_min_pic%2F16%2F10%2F29%2F2ac8e99273bc079e40a8dc079ca11b1f.jpg&refer=http%3A%2F%2Fbpic.588ku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637389812&t=02c65a6ed86d4cacf7b8335c66778970'
          // img.crossOrigin = 'anonymous'
          // img.onload = function () {
          //   ctx.drawImage(img, 0, 0, that.widthD, that.heightD, 0, 0, that.widthD, that.heightD)
          //   // drawImage(img,sx,sy,swidth,sheight,x,y,width,height) : 剪切图像，并在画布上
          //   // sx 开始剪切的图片上的x位置
          //   // sy 开始剪切的图片上的y位置
          //   // swidth 被剪切的宽度
          //   // sheight 被剪切的高度
          //   // x 在画布上放置图像的x位置
          //   // y 在画布上放置图像的y位置
          //   // width 要使用的图像宽度
          //   // height 要使用的图像高度
          //   const dataURL = canvas.toDataURL('image/jpeg')
          //   that.imgURL = dataURL
          //   console.log(11)
          // }
        }
      }
    })
  </script>
</body>
</html>